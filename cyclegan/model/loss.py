import torch
import torch.nn as nn

class CycleConsistencyLoss(nn.Module):
    def __init__(self, device='cuda'):
        super(CycleConsistencyLoss, self).__init__()
        self.device = device
        self.l1_loss = nn.L1Loss()

    def forward(self, x, x_rec):
        loss = self.l1_loss(x, x_rec)
        return loss

class AdversarialLossCE(nn.Module):
    def __init__(self, device='cuda'):
        super(AdversarialLossCE, self).__init__()
        self.device = device
        self.bce_loss = nn.BCEWithLogitsLoss()

    def forward(self, real_pred, fake_pred=None):
        if fake_pred is not None: # only discriminator
            ones = torch.ones_like(real_pred, device=self.device)
            zeros = torch.zeros_like(fake_pred, device=self.device)

            loss = self.bce_loss(real_pred, ones) + self.bce_loss(fake_pred, zeros)
        else: # only generator; real_pred -- prediction of the discriminator on the fake images generated by the generator
            ones = torch.ones_like(real_pred, device=self.device)
            loss = self.bce_loss(real_pred, ones)

        return loss


class AdversarialLossMSE(nn.Module):
    def __init__(self, device='cuda'):
        super(AdversarialLossMSE, self).__init__()
        self.device = device
        self.l2_loss = nn.MSELoss()

    def forward(self, real_pred, fake_pred=None):
        if fake_pred is not None: # only discriminator
            ones = torch.ones_like(real_pred, device=self.device)
            zeros = torch.zeros_like(fake_pred, device=self.device)

            loss = self.l2_loss(real_pred, ones) + self.l2_loss(fake_pred, zeros)
        else: # only generator; real_pred -- prediction of the discriminator on the fake images generated by the generator
            ones = torch.ones_like(real_pred, device=self.device)
            loss = self.l2_loss(real_pred, ones)

        return loss

class FullDiscriminatorLoss(nn.Module):
    def __init__(self, is_mse=True, device='cuda'):
        super(FullDiscriminatorLoss, self).__init__()
        self.adversarial_loss_func = AdversarialLossMSE(device=device) if is_mse else AdversarialLossCE(device=device)

    def forward(
        self,
        a_real_pred,
        b_real_pred,
        a_fake_pred,
        b_fake_pred,
    ):
        loss = self.adversarial_loss_func(a_real_pred, a_fake_pred) + \
               self.adversarial_loss_func(b_real_pred, b_fake_pred)

        return loss

class FullGeneratorLoss(nn.Module):
    def __init__(self, lambda_value=10., is_mse=True, device='cuda'):
        super(FullGeneratorLoss, self).__init__()
        self.adversarial_loss_func = AdversarialLossMSE(device=device) if is_mse else AdversarialLossCE(device=device)
        self.cycle_consistency_loss_func = CycleConsistencyLoss(device=device)
        self.lambda_value = lambda_value

    def forward(
        self,
        a_real,
        b_real,
        a_rec,
        b_rec,
        a_fake_pred,
        b_fake_pred,
    ):
        loss = self.adversarial_loss_func(a_fake_pred) + \
               self.adversarial_loss_func(b_fake_pred) + \
               self.lambda_value * self.cycle_consistency_loss_func(a_real, a_rec) + \
               self.lambda_value * self.cycle_consistency_loss_func(b_real, b_rec)
        return loss
